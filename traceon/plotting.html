<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>traceon.plotting API documentation</title>
<meta name="description" content="The `traceon.plotting` module uses `matplotlib` to provide some convenience functions
to show the line and triangle meshes generated by Traceon." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>traceon.plotting</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="traceon.plotting" href="#traceon.plotting">traceon.plotting</a></code> module uses <code>matplotlib</code> to provide some convenience functions
to show the line and triangle meshes generated by Traceon.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The `traceon.plotting` module uses `matplotlib` to provide some convenience functions
to show the line and triangle meshes generated by Traceon.&#34;&#34;&#34;

import matplotlib.tri as mtri
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from scipy.interpolate import *
import numpy as np

from . import backend

def _create_point_to_physical_dict(mesh):
    d = {}
    
    for k, v in mesh.cell_sets_dict.items():
        
        if &#39;triangle&#39; in v: 
            for p in mesh.cells_dict[&#39;triangle&#39;][v[&#39;triangle&#39;]]:
                a, b, c = p
                d[a], d[b], d[c] = k, k, k
        
        if &#39;line&#39; in v:
            for l in mesh.cells_dict[&#39;line&#39;][v[&#39;line&#39;]]:
                a, b = l
                d[a], d[b] = k, k
     
    return d

# Taken from
# https://stackoverflow.com/questions/13685386/matplotlib-equal-unit-length-with-equal-aspect-ratio-z-axis-is-not-equal-to
def _set_axes_equal(ax):
    &#34;&#34;&#34;Set 3D plot axes to equal scale.

    Make axes of 3D plot have equal scale so that spheres appear as
    spheres and cubes as cubes.  Required since `ax.axis(&#39;equal&#39;)`
    and `ax.set_aspect(&#39;equal&#39;)` don&#39;t work on 3D.
    &#34;&#34;&#34;
    limits = np.array([
        ax.get_xlim3d(),
        ax.get_ylim3d(),
        ax.get_zlim3d(),
    ])
    x, y, z = np.mean(limits, axis=1)
    radius = 0.5 * np.max(np.abs(limits[:, 1] - limits[:, 0]))
    ax.set_xlim3d([x - radius, x + radius])
    ax.set_ylim3d([y - radius, y + radius])
    ax.set_zlim3d([z - radius, z + radius])

def plot_triangle_mesh(mesh, show_legend=True, **colors):
    &#34;&#34;&#34;Show a 3D mesh (mesh consisting of many triangles).

    Parameters
    ----------
    mesh: meshio mesh
        The mesh to show.

    show_legend: bool
        Whether to show a legend, the colors will correspond to different physical groups.
    
    colors: dict
        What colors to use for the different physical groups in the geometry. The keys in the dictionary correspond to the
        physical group names, while the values can be any color understood by matplotlib.
    &#34;&#34;&#34;
    plt.figure(figsize=(10, 13))
    ax = plt.axes(projection=&#39;3d&#39;)
    plt.plot([0, 0], [0, 0], [np.min(mesh.points[:, 2]), np.max(mesh.points[:, 2])], color=&#39;black&#39;, linestyle=&#39;dashed&#39;)
    ax.set_box_aspect([1,1,1])
    _set_axes_equal(ax)
     
    plt.rcParams.update({&#39;font.size&#39;: 17})
    
    dict_ = _create_point_to_physical_dict(mesh)
    triangles = mesh.cells_dict[&#39;triangle&#39;]
     
    triangles_to_plot = []
    colors_ = []
    
    for (A, B, C) in triangles:
        color = &#39;#CCC&#39;
        
        if A in dict_ and B in dict_ and C in dict_:
            phys1, phys2, phys3 = dict_[A], dict_[B], dict_[C]
            if phys1 == phys2 and phys2 == phys3 and phys1 in colors:
                color = colors[phys1]
         
        triangles_to_plot.append( [A, B, C] )
        colors_.append(color)
     
    colors_, triangles_to_plot = np.array(colors_), np.array(triangles_to_plot)
     
    for c in set(colors_):
        mask = colors_ == c
        ax.plot_trisurf(mesh.points[:, 0], mesh.points[:, 1], mesh.points[:, 2], triangles=triangles_to_plot[mask], color=c)

    # TODO: reimplement functionality
    show_normals = False
    if show_normals:
        normals = np.zeros( (len(triangles_to_plot), 6) )
        for i, t in enumerate(triangles_to_plot):
            v1, v2, v3 = mesh.points[t]
            middle = (v1 + v2 + v3)/3
            normal = 0.1*backend.normal_3d(v1, v2, v3)
            normals[i] = [*middle, *normal]
         
        ax.quiver(*normals.T)
     
    if show_legend:
        for l, c in colors.items():
            plt.plot([], [], label=l, color=c)
        plt.legend(loc=&#39;upper left&#39;)
     
    plt.xlabel(&#39;x (mm)&#39;)
    plt.ylabel(&#39;y (mm)&#39;)
    ax.set_zlabel(&#39;z (mm)&#39;)
    plt.show()


def plot_line_mesh(mesh, trajectory=None, show_legend=True, **colors):
    &#34;&#34;&#34;Show a 2D mesh (mesh consisting of many line elements).
    
    Parameters
    ---------
    mesh: meshio object
        The mesh to show.
    trajectory: (N, 2) np.ndarray
        Optionally also show a trajectory inside the geometry. The trajectory
        can simply be the position values returned when calling `traceon.tracing.Tracer`.
    show_legend: bool
        Whether to show a legend. The colors in the legend will correspond to the different physical
        groups present in the geometry.
    colors: dict
        The colors to use for the physical groups. The keys in the dictionary correspond to the
        physical group names, while the values can be any color understood by matplotlib.
    &#34;&#34;&#34;
    plt.figure(figsize=(10, 13))
    plt.rcParams.update({&#39;font.size&#39;: 17})
    plt.gca().set_aspect(&#39;equal&#39;)
     
    dict_ = _create_point_to_physical_dict(mesh)
    lines = mesh.cells_dict[&#39;line&#39;]

    to_plot_x = []
    to_plot_y = []
    colors_ = []
    
    for (A, B) in lines:
        color = &#39;#CCC&#39;

        if A in dict_ and B in dict_:
            phys1, phys2 = dict_[A], dict_[B]
            if phys1 == phys2 and phys1 in colors:
                color = colors[phys1]
         
        p1, p2 = mesh.points[A], mesh.points[B]
        to_plot_x.append( [p1[0], p2[0]] )
        to_plot_y.append( [p1[1], p2[1]] )
        colors_.append(color)
     
    colors_ = np.array(colors_)
     
    for c in set(colors_):
        mask = colors_ == c
        plt.plot(np.array(to_plot_x)[mask].T, np.array(to_plot_y)[mask].T, color=c, linewidth=2)
        plt.scatter(np.array(to_plot_x)[mask].T, np.array(to_plot_y)[mask].T, color=c, s=15)

    if show_legend:
        for l, c in colors.items():
            plt.plot([], [], label=l, color=c)
        plt.legend(loc=&#39;upper left&#39;)
     
    plt.xlabel(&#39;r (mm)&#39;)
    plt.ylabel(&#39;z (mm)&#39;)
    plt.axvline(0, color=&#39;black&#39;, linestyle=&#39;dashed&#39;)
    plt.xlim(-0.25, None)

    if trajectory is not None:
        plt.plot(trajectory[:, 0], trajectory[:, 1])
    plt.show()

&#39;&#39;&#39;
def show_charge_density(lines, charges):
    # See https://matplotlib.org/stable/gallery/lines_bars_and_markers/multicolored_line.html
    assert len(lines) == len(charges)

    plt.figure()
    segments = lines[:, :, :2] # Remove z value
    
    amplitude = np.mean(np.abs(charges))
    norm = plt.Normalize(-3*amplitude, 3*amplitude)
    
    lc = LineCollection(segments, cmap=&#39;coolwarm&#39;, norm=norm)
    lc.set_array(charges)
    lc.set_linewidth(4)
    line = plt.gca().add_collection(lc)
    plt.xlim(np.min(lines[:, :, 0])-0.2, np.max(lines[:, :, 0])+0.2)
    plt.ylim(np.min(lines[:, :, 1])-0.2, np.max(lines[:, :, 1])+0.2)
    plt.xlabel(&#39;r (mm)&#39;)
    plt.ylabel(&#39;z (mm)&#39;)
    plt.show()
&#39;&#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="traceon.plotting.plot_line_mesh"><code class="name flex">
<span>def <span class="ident">plot_line_mesh</span></span>(<span>mesh, trajectory=None, show_legend=True, **colors)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a 2D mesh (mesh consisting of many line elements).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>meshio object</code></dt>
<dd>The mesh to show.</dd>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>(N, 2) np.ndarray</code></dt>
<dd>Optionally also show a trajectory inside the geometry. The trajectory
can simply be the position values returned when calling <code><a title="traceon.tracing.Tracer" href="tracing.html#traceon.tracing.Tracer">Tracer</a></code>.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show a legend. The colors in the legend will correspond to the different physical
groups present in the geometry.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>dict</code></dt>
<dd>The colors to use for the physical groups. The keys in the dictionary correspond to the
physical group names, while the values can be any color understood by matplotlib.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_line_mesh(mesh, trajectory=None, show_legend=True, **colors):
    &#34;&#34;&#34;Show a 2D mesh (mesh consisting of many line elements).
    
    Parameters
    ---------
    mesh: meshio object
        The mesh to show.
    trajectory: (N, 2) np.ndarray
        Optionally also show a trajectory inside the geometry. The trajectory
        can simply be the position values returned when calling `traceon.tracing.Tracer`.
    show_legend: bool
        Whether to show a legend. The colors in the legend will correspond to the different physical
        groups present in the geometry.
    colors: dict
        The colors to use for the physical groups. The keys in the dictionary correspond to the
        physical group names, while the values can be any color understood by matplotlib.
    &#34;&#34;&#34;
    plt.figure(figsize=(10, 13))
    plt.rcParams.update({&#39;font.size&#39;: 17})
    plt.gca().set_aspect(&#39;equal&#39;)
     
    dict_ = _create_point_to_physical_dict(mesh)
    lines = mesh.cells_dict[&#39;line&#39;]

    to_plot_x = []
    to_plot_y = []
    colors_ = []
    
    for (A, B) in lines:
        color = &#39;#CCC&#39;

        if A in dict_ and B in dict_:
            phys1, phys2 = dict_[A], dict_[B]
            if phys1 == phys2 and phys1 in colors:
                color = colors[phys1]
         
        p1, p2 = mesh.points[A], mesh.points[B]
        to_plot_x.append( [p1[0], p2[0]] )
        to_plot_y.append( [p1[1], p2[1]] )
        colors_.append(color)
     
    colors_ = np.array(colors_)
     
    for c in set(colors_):
        mask = colors_ == c
        plt.plot(np.array(to_plot_x)[mask].T, np.array(to_plot_y)[mask].T, color=c, linewidth=2)
        plt.scatter(np.array(to_plot_x)[mask].T, np.array(to_plot_y)[mask].T, color=c, s=15)

    if show_legend:
        for l, c in colors.items():
            plt.plot([], [], label=l, color=c)
        plt.legend(loc=&#39;upper left&#39;)
     
    plt.xlabel(&#39;r (mm)&#39;)
    plt.ylabel(&#39;z (mm)&#39;)
    plt.axvline(0, color=&#39;black&#39;, linestyle=&#39;dashed&#39;)
    plt.xlim(-0.25, None)

    if trajectory is not None:
        plt.plot(trajectory[:, 0], trajectory[:, 1])
    plt.show()</code></pre>
</details>
</dd>
<dt id="traceon.plotting.plot_triangle_mesh"><code class="name flex">
<span>def <span class="ident">plot_triangle_mesh</span></span>(<span>mesh, show_legend=True, **colors)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a 3D mesh (mesh consisting of many triangles).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>meshio mesh</code></dt>
<dd>The mesh to show.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show a legend, the colors will correspond to different physical groups.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>dict</code></dt>
<dd>What colors to use for the different physical groups in the geometry. The keys in the dictionary correspond to the
physical group names, while the values can be any color understood by matplotlib.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_triangle_mesh(mesh, show_legend=True, **colors):
    &#34;&#34;&#34;Show a 3D mesh (mesh consisting of many triangles).

    Parameters
    ----------
    mesh: meshio mesh
        The mesh to show.

    show_legend: bool
        Whether to show a legend, the colors will correspond to different physical groups.
    
    colors: dict
        What colors to use for the different physical groups in the geometry. The keys in the dictionary correspond to the
        physical group names, while the values can be any color understood by matplotlib.
    &#34;&#34;&#34;
    plt.figure(figsize=(10, 13))
    ax = plt.axes(projection=&#39;3d&#39;)
    plt.plot([0, 0], [0, 0], [np.min(mesh.points[:, 2]), np.max(mesh.points[:, 2])], color=&#39;black&#39;, linestyle=&#39;dashed&#39;)
    ax.set_box_aspect([1,1,1])
    _set_axes_equal(ax)
     
    plt.rcParams.update({&#39;font.size&#39;: 17})
    
    dict_ = _create_point_to_physical_dict(mesh)
    triangles = mesh.cells_dict[&#39;triangle&#39;]
     
    triangles_to_plot = []
    colors_ = []
    
    for (A, B, C) in triangles:
        color = &#39;#CCC&#39;
        
        if A in dict_ and B in dict_ and C in dict_:
            phys1, phys2, phys3 = dict_[A], dict_[B], dict_[C]
            if phys1 == phys2 and phys2 == phys3 and phys1 in colors:
                color = colors[phys1]
         
        triangles_to_plot.append( [A, B, C] )
        colors_.append(color)
     
    colors_, triangles_to_plot = np.array(colors_), np.array(triangles_to_plot)
     
    for c in set(colors_):
        mask = colors_ == c
        ax.plot_trisurf(mesh.points[:, 0], mesh.points[:, 1], mesh.points[:, 2], triangles=triangles_to_plot[mask], color=c)

    # TODO: reimplement functionality
    show_normals = False
    if show_normals:
        normals = np.zeros( (len(triangles_to_plot), 6) )
        for i, t in enumerate(triangles_to_plot):
            v1, v2, v3 = mesh.points[t]
            middle = (v1 + v2 + v3)/3
            normal = 0.1*backend.normal_3d(v1, v2, v3)
            normals[i] = [*middle, *normal]
         
        ax.quiver(*normals.T)
     
    if show_legend:
        for l, c in colors.items():
            plt.plot([], [], label=l, color=c)
        plt.legend(loc=&#39;upper left&#39;)
     
    plt.xlabel(&#39;x (mm)&#39;)
    plt.ylabel(&#39;y (mm)&#39;)
    ax.set_zlabel(&#39;z (mm)&#39;)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="traceon" href="index.html">traceon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="traceon.plotting.plot_line_mesh" href="#traceon.plotting.plot_line_mesh">plot_line_mesh</a></code></li>
<li><code><a title="traceon.plotting.plot_triangle_mesh" href="#traceon.plotting.plot_triangle_mesh">plot_triangle_mesh</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>